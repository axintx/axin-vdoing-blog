(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{389:function(a,v,_){"use strict";_.r(v);var l=_(0),s=Object(l.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"基础知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础知识"}},[a._v("#")]),a._v(" 基础知识")]),a._v(" "),v("h2",{attrs:{id:"classloader"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#classloader"}},[a._v("#")]),a._v(" ClassLoader")]),a._v(" "),v("h3",{attrs:{id:"类的生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期"}},[a._v("#")]),a._v(" 类的生命周期")]),a._v(" "),v("ol",[v("li",[a._v("加载（Loading）：找 Class 文件")]),a._v(" "),v("li",[a._v("验证（Verification） ：验证格式、依赖")]),a._v(" "),v("li",[a._v("准备（Preparation）：静态字段、方法表")]),a._v(" "),v("li",[a._v("解析（Resolution）：符号解析为引用")]),a._v(" "),v("li",[a._v("初始化（Initialization）：构造器、静态变量赋值、静态代码块")]),a._v(" "),v("li",[a._v("使用（Using）")]),a._v(" "),v("li",[a._v("卸载（Unloading）")])]),a._v(" "),v("h3",{attrs:{id:"类的加载时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类的加载时机"}},[a._v("#")]),a._v(" 类的加载时机")]),a._v(" "),v("ol",[v("li",[a._v("当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类")]),a._v(" "),v("li",[a._v("当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化")]),a._v(" "),v("li",[a._v("当遇到调用静态方法指令时，初始化该静态方法所在的类")]),a._v(" "),v("li",[a._v("当遇到访问静态方法指令时，初始化该静态方法所在的类")]),a._v(" "),v("li",[a._v("子类的初始化会触发父类的初始化")]),a._v(" "),v("li",[a._v("如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化")]),a._v(" "),v("li",[a._v("使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化")]),a._v(" "),v("li",[a._v("当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在类")])]),a._v(" "),v("h3",{attrs:{id:"类不会初始化-可能会加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类不会初始化-可能会加载"}},[a._v("#")]),a._v(" 类不会初始化（可能会加载）")]),a._v(" "),v("ol",[v("li",[a._v("通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化")]),a._v(" "),v("li",[a._v("定义对象数组，不会触发该类的初始化")]),a._v(" "),v("li",[a._v("常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类")]),a._v(" "),v("li",[a._v("通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化")]),a._v(" "),v("li",[a._v('通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName ("jvm.Hello") 默认会加载 Hello 类')]),a._v(" "),v("li",[a._v("通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）")])]),a._v(" "),v("h3",{attrs:{id:"三类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三类加载器"}},[a._v("#")]),a._v(" 三类加载器")]),a._v(" "),v("ol",[v("li",[a._v("启动类加载器")]),a._v(" "),v("li",[a._v("扩展类加载器")]),a._v(" "),v("li",[a._v("应用类加载器")])]),a._v(" "),v("p",[v("strong",[a._v("特点")]),a._v("：")]),a._v(" "),v("ul",[v("li",[a._v("双亲委托")]),a._v(" "),v("li",[a._v("负责依赖")]),a._v(" "),v("li",[a._v("缓存加载")])]),a._v(" "),v("h3",{attrs:{id:"添加引用类的几种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#添加引用类的几种方式"}},[a._v("#")]),a._v(" 添加引用类的几种方式")]),a._v(" "),v("ol",[v("li",[a._v("放在 JDK 的 lib/ext 下， 或者运行时参数 -Djava.ext.dirs 指定路径")]),a._v(" "),v("li",[a._v("java -cp/classpath  或者 class 文件放到当前路径")]),a._v(" "),v("li",[a._v("自定义 ClassLoader 加载")]),a._v(" "),v("li",[a._v("拿到当前执行类的 ClassLoader， 反射调用 addUrl 方法添加 Jar 或路径 （JDK9 无效）")])]),a._v(" "),v("h2",{attrs:{id:"jvm-内存模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存模型"}},[a._v("#")]),a._v(" JVM 内存模型")]),a._v(" "),v("h3",{attrs:{id:"jvm-内存结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存结构"}},[a._v("#")]),a._v(" JVM 内存结构")])])}),[],!1,null,null,null);v.default=s.exports}}]);